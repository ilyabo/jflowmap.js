// Generated by CoffeeScript 1.3.0
(function() {
  var fg, geoPath, h, m, map, mscale, perpendicularSegment, projection, rnd, svg, vis, w;

  rnd = d3.random.normal(30, 70);

  w = 640;

  h = 480;

  m = {
    t: 15,
    r: 15,
    b: 15,
    l: 15
  };

  m.w = m.l + m.r;

  m.h = m.t + m.b;

  svg = d3.select("body").append("svg").attr({
    width: w,
    height: h
  });

  vis = svg.append("g").attr({
    transform: "translate(" + m.l + ", " + m.t + ")"
  });

  fg = svg.append("rect").attr({
    width: w,
    height: h,
    stroke: "#000",
    fill: "#fff",
    "fill-opacity": 0
  });

  map = vis.append("g").attr("class", "map");

  mscale = d3.scale.linear().range([0, 10]).domain([0, 100]);

  perpendicularSegment = function(a, b, length, p) {
    var d, u, v, vnorm;
    v = [b[0] - a[0], b[1] - a[1]];
    vnorm = Math.sqrt(v[0] * v[0] + v[1] * v[1]);
    u = [v[0] / vnorm, v[1] / vnorm];
    u = [-u[1], u[0]];
    d = [u[0] * length / 2, u[1] * length / 2];
    return [[+p[0] + d[0], +p[1] + d[1]], [+p[0] - d[0], +p[1] - d[1]]];
  };

  projection = d3.geo.albers().rotate([0, 0]).center([9.6, 46.6]).scale(10300);

  geoPath = d3.geo.path().projection(projection);

  queue().defer(d3.json, "data/swiss-cantons-simplified.json").defer(d3.json, "data/flows.json").await(function(err, mapData, flowData) {
    var data, diff, duration, flowLine, flows, geometries, mapShapes, nodes, norm;
    geometries = topojson.object(mapData, mapData.objects["swiss-cantons"]).geometries;
    mapShapes = map.selectAll("path").data(geometries);
    mapShapes.enter().append('path').attr({
      d: geoPath,
      opacity: 0.01
    });
    diff = function(a, b) {
      return [a[0] - b[0], a[1] - b[1]];
    };
    norm = function(v) {
      return Math.sqrt(v[0] * v[0] + v[1] * v[1]);
    };
    data = (function() {
      var ndata;
      ndata = geometries.map(function(d) {
        var centroid;
        centroid = projection(d3.geo.centroid(d));
        return {
          name: d.properties.abbr,
          c: centroid
        };
      });
      return {
        nodes: ndata,
        flows: flowData
      };
    })();
    flowLine = (function() {
      var arrowLength, arrowWingSize, gap, pointBetween;
      gap = 0.5;
      arrowLength = 2;
      arrowWingSize = 1;
      pointBetween = function(a, b, distFromB) {
        var d, len, normalized;
        d = diff(a, b);
        len = norm(d);
        normalized = [d[0] / len, d[1] / len];
        return [b[0] + distFromB * normalized[0], b[1] + distFromB * normalized[1]];
      };
      return function(origin, dest, thickness, shortenOriginBy, shortenDestBy) {
        var a, b, p0, p1, p2, p3, p4, p_, _ref;
        if (shortenOriginBy == null) {
          shortenOriginBy = 6;
        }
        if (shortenDestBy == null) {
          shortenDestBy = 6;
        }
        _ref = [origin, dest], a = _ref[0], b = _ref[1];
        b = pointBetween(a, b, shortenDestBy);
        a = pointBetween(b, a, shortenOriginBy);
        p0 = perpendicularSegment(a, b, gap * 2, a)[1];
        p1 = perpendicularSegment(a, b, (gap + thickness) * 2, a)[1];
        p_ = perpendicularSegment(a, b, (gap + thickness) * 2, b)[1];
        p2 = pointBetween(p1, p_, arrowLength * thickness);
        p3 = perpendicularSegment(p1, p_, thickness * 2 * arrowWingSize, p2)[1];
        p4 = perpendicularSegment(a, b, gap * 2, b)[1];
        return "M " + p0[0] + "," + p0[1] + "\nL " + p1[0] + "," + p1[1] + "\nL " + p2[0] + "," + p2[1] + "\nL " + p3[0] + "," + p3[1] + "\nL " + p4[0] + "," + p4[1] + " Z ";
      };
    })();
    flows = vis.selectAll("path.flow").data(data.flows).enter().append("svg:path").attr({
      "class": "flow",
      opacity: 0.01,
      d: function(d) {
        return flowLine(d.origin.c, d.dest.c, mscale(d.magnitude));
      }
    });
    flows.append("svg:title").text(function(d) {
      return d.origin.name + "->" + d.dest.name + ": " + d.magnitude;
    });
    vis.selectAll("path.flow").sort(function(a, b) {
      return d3.ascending(a.magnitude, b.magnitude);
    });
    nodes = vis.selectAll("g.node").data(data.nodes).enter().append("svg:g").attr({
      "class": "node",
      opacity: 0.01,
      transform: function(d) {
        return "translate(" + d.c[0] + "," + d.c[1] + ")";
      }
    });
    nodes.append("svg:circle").attr({
      cx: 0,
      cy: 0,
      r: 4
    });
    nodes.append("svg:text").text(function(d) {
      return d.name;
    });
    duration = 500;
    vis.selectAll("g.node").transition().duration(duration).attr("opacity", 1);
    map.selectAll("path").transition().duration(duration).attr("opacity", 0.5);
    return vis.selectAll("path.flow").transition().duration(duration).attr("opacity", 1);
  });

}).call(this);
